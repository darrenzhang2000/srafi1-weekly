---
title: Week 12
layout: post
---

# Transfer Issues with Hub

This week, I set out to implement a feature for transferring issues between repositories as requested in issue [#2252](https://github.com/github/hub/issues/2252) of Hub. Specifically, it meant adding a subcommand under `issue` in the format `$ hub issue transfer <ISSUE-NUMBER> <TARGET-REPO>`. The project's main maintainer already outlined a solution to this feature using three GraphQL requests in [this script](https://github.com/mislav/hub-api-utils/blob/master/bin/hub-issue-transfer), so all I had to do was implement that in Go and have a subcommand point to it. 

I started off by figuring out how to add a subcommand, which turned out to be pretty simple. Hub has infrastructure written to define subcommands with documentation, so all I had to do was create a `Command` object and then add the line `cmdIssue.Use(cmdTransfer)` to the `init()` function. I had this subcommand point to a function that just printed out "transferring issue."

After that, I wrote a few lines to store the issue number and target repo inputs in variables. Again, Hub has infrastructure to do this easily, so it wasn't a problem. I also didn't have to do much input validation because any invalid inputs would be rejected by the GitHub API anyway. All I did was make sure that there were at least two inputs. More inputs would be allowed, but would be ignored by the program.

Next came what I thought would be the hard part. I didn't know the syntax for GraphQL. I knew the general idea behind it, but I had to spend a bit of time learning the syntax so I could format the API requests properly. This part didn't end up taking much time because I had a script to work off of already. I wrote some code to send the first API request and dumped its data to the command line. So far so good.

Afterwards I ran into the actual hard part: parsing JSON data from the API response. I'd parsed JSON data in dynamic languages like Python before and it works well with dynamic data just because of the nature of those languages. However, Go is a strictly typed language, so parsing JSON data and loading it into a variable was tricky. I looked through the documentation for Go's built in JSON library and found the `Unmarshal()` function. This function takes a stream of data and stores it in a map of strings to interfaces. In Go, an interface matches any type as a mechanism for dealing with unstructured data. This allowed me to parse the JSON data, but it required me to use a lot of type-casting, which didn't feel like the right way to go about solving the problem at hand. I didn't know any other ways to parse JSON data, so I just left it like that and added a bit of error checking after sending each API request to make sure that the program doesn't break in cases such as the user specifies a repository that doesn't exist or the user doesn't have a network connection.

Finally, I did a bit of testing with a couple of repositories that I made under my account and it seemed to work, so I submitted a [pull request](https://github.com/github/hub/pull/2363). The pull request was reviewed two days later with some feedback about my code. There were a few project conventions that I missed and need to fix, but, more importantly, the reviewer suggested a much better way to parse the JSON data. His method involves defining a struct based on the expected format of the JSON and then calling `Unmarshall()`. The resulting code is much cleaner that is easier to read. I also forgot to write tests for my code. I'll have to make some time this weekend to implement the changes and then update the pull request, but it's looking pretty good so far.
